# @generated AUTOGENERATED file. Do not Change!
# flake8: noqa
# fmt: off
# isort: skip_file
# pylint: skip-file

import copy
import inspect
import typing
from dataclasses import dataclass
import utils
import datetime


def demangle(data, attrs):
    data = copy.copy(data)
    for attr in attrs:
        data[attr[1:]] = data.pop(attr)
    return data


################################################################################
# enum
Episode = typing.Literal["NEWHOPE", "EMPIRE", "JEDI"]


################################################################################
# input


AddStarshipInput__required = typing.TypedDict("AddStarshipInput__required", {"name": str})
AddStarshipInput__not_required = typing.TypedDict("AddStarshipInput__not_required", {}, total=False)


class AddStarshipInput(AddStarshipInput__required, AddStarshipInput__not_required):
    pass


def AddStarshipInput__serialize(data):
    ret = copy.copy(data)
    return ret


################################################################################
# type
@dataclass
class GetObject__droid:
    _typename: typing.Literal["Droid"]
    appearsIn: typing.List[Episode]
    id: str
    name: str
    primaryFunction: str
    def __init__(self, _typename, appearsIn, id, name, primaryFunction):
        self._typename = _typename
        self.appearsIn = appearsIn
        self.id = id
        self.name = name
        self.primaryFunction = primaryFunction


@dataclass
class GetInterface__hero:
    id: str
    name: str
    def __init__(self, id, name):
        self.id = id
        self.name = name


@dataclass
class GetInlineFragment__hero__Droid:
    _typename: typing.Literal["Droid"]
    id: str
    name: str
    primaryFunction: str
    def __init__(self, _typename, id, name, primaryFunction):
        self._typename = _typename
        self.id = id
        self.name = name
        self.primaryFunction = primaryFunction


@dataclass
class GetInlineFragment__hero__Human:
    _typename: typing.Literal["Human"]
    id: str
    name: str
    totalCredits: int
    def __init__(self, _typename, id, name, totalCredits):
        self._typename = _typename
        self.id = id
        self.name = name
        self.totalCredits = int(totalCredits)


@dataclass
class GetInlineFragment__hero:
    _typename: typing.Literal["Character"]
    id: str
    name: str
    def __init__(self, _typename, id, name):
        self._typename = _typename
        self.id = id
        self.name = name


@dataclass
class GetUnion__search__Starship:
    _typename: typing.Literal["Starship"]
    name: str
    def __init__(self, _typename, name):
        self._typename = _typename
        self.name = name


@dataclass
class GetUnion__search__Droid__friends:
    name: str
    def __init__(self, name):
        self.name = name


@dataclass
class GetUnion__search__Droid:
    _typename: typing.Literal["Droid"]
    friends: typing.List[typing.Optional[GetUnion__search__Droid__friends]]
    def __init__(self, _typename, friends):
        self._typename = _typename
        self.friends = [GetUnion__search__Droid__friends(**friends__iter) if friends__iter else None for friends__iter in friends]


@dataclass
class GetUnion__search__Human:
    _typename: typing.Literal["Human"]
    totalCredits: int
    def __init__(self, _typename, totalCredits):
        self._typename = _typename
        self.totalCredits = int(totalCredits)


@dataclass
class GetUnion__search:
    _typename: typing.Literal["SearchResult"]
    def __init__(self, _typename):
        self._typename = _typename


@dataclass
class GetRecursive__hero__Droid__friends__Droid__friends:
    name: str
    def __init__(self, name):
        self.name = name


@dataclass
class GetRecursive__hero__Droid__friends__Droid:
    _typename: typing.Literal["Droid"]
    friends: typing.List[typing.Optional[GetRecursive__hero__Droid__friends__Droid__friends]]
    id: str
    name: str
    def __init__(self, _typename, friends, id, name):
        self._typename = _typename
        self.friends = [GetRecursive__hero__Droid__friends__Droid__friends(**friends__iter) if friends__iter else None for friends__iter in friends]
        self.id = id
        self.name = name


@dataclass
class GetRecursive__hero__Droid__friends__Human__starships:
    name: str
    def __init__(self, name):
        self.name = name


@dataclass
class GetRecursive__hero__Droid__friends__Human:
    _typename: typing.Literal["Human"]
    id: str
    name: str
    starships: typing.List[typing.Optional[GetRecursive__hero__Droid__friends__Human__starships]]
    def __init__(self, _typename, id, name, starships):
        self._typename = _typename
        self.id = id
        self.name = name
        self.starships = [GetRecursive__hero__Droid__friends__Human__starships(**starships__iter) if starships__iter else None for starships__iter in starships]


@dataclass
class GetRecursive__hero__Droid__friends:
    _typename: typing.Literal["Character"]
    id: str
    def __init__(self, _typename, id):
        self._typename = _typename
        self.id = id


@dataclass
class GetRecursive__hero__Droid:
    _typename: typing.Literal["Droid"]
    friends: typing.List[typing.Optional[GetRecursive__hero__Droid__friends]]
    name: str
    primaryFunction: str
    def __init__(self, _typename, friends, name, primaryFunction):
        self._typename = _typename
        __friends_map = {
            "Human": GetRecursive__hero__Droid__friends__Human,
            "Droid": GetRecursive__hero__Droid__friends__Droid,
        }
        self.friends = [__friends_map.get(friends__iter["__typename"], GetRecursive__hero__Droid__friends)(**demangle(friends__iter, ['__typename'])) if friends__iter else None for friends__iter in friends]
        self.name = name
        self.primaryFunction = primaryFunction


@dataclass
class GetRecursive__hero__Human__friends__Droid:
    _typename: typing.Literal["Droid"]
    id: str
    name: str
    def __init__(self, _typename, id, name):
        self._typename = _typename
        self.id = id
        self.name = name


@dataclass
class GetRecursive__hero__Human__friends__Human:
    _typename: typing.Literal["Human"]
    name: str
    def __init__(self, _typename, name):
        self._typename = _typename
        self.name = name


@dataclass
class GetRecursive__hero__Human__friends:
    _typename: typing.Literal["Character"]
    def __init__(self, _typename):
        self._typename = _typename


@dataclass
class GetRecursive__hero__Human:
    _typename: typing.Literal["Human"]
    friends: typing.List[typing.Optional[GetRecursive__hero__Human__friends]]
    name: str
    def __init__(self, _typename, friends, name):
        self._typename = _typename
        __friends_map = {
            "Human": GetRecursive__hero__Human__friends__Human,
            "Droid": GetRecursive__hero__Human__friends__Droid,
        }
        self.friends = [__friends_map.get(friends__iter["__typename"], GetRecursive__hero__Human__friends)(**demangle(friends__iter, ['__typename'])) if friends__iter else None for friends__iter in friends]
        self.name = name


@dataclass
class GetRecursive__hero:
    _typename: typing.Literal["Character"]
    name: str
    def __init__(self, _typename, name):
        self._typename = _typename
        self.name = name


@dataclass
class AddStarship__addStarship:
    id: str
    name: str
    def __init__(self, id, name):
        self.id = id
        self.name = name


@dataclass
class AllHuman__allHuman:
    id: str
    name: str
    def __init__(self, id, name):
        self.id = id
        self.name = name


################################################################################
# GetScalar
@dataclass
class GetScalarResponse:
    hello: str
    def __init__(self, hello):
        self.hello = hello


_GetScalarInput__required = typing.TypedDict("_GetScalarInput__required", {})
_GetScalarInput__not_required = typing.TypedDict("_GetScalarInput__not_required", {}, total=False)


class _GetScalarInput(_GetScalarInput__required, _GetScalarInput__not_required):
    pass


def _GetScalarInput__serialize(data):
    ret = copy.copy(data)
    return ret


class GetScalar(utils.Client[_GetScalarInput, GetScalarResponse]):
    _query = inspect.cleandoc('''
        query GetScalar {
          hello
        }
    ''')
    Input: typing.TypeAlias = _GetScalarInput
    Response: typing.TypeAlias = GetScalarResponse

    @classmethod
    def serialize(cls, data: _GetScalarInput):
        return {
            "operation_name": "GetScalar",
            "query": cls._query,
            "variables": _GetScalarInput__serialize(data),
        }

    @classmethod
    def deserialize(cls, data):
        return cls.Response(**data)


################################################################################
# GetObject
@dataclass
class GetObjectResponse:
    droid: GetObject__droid
    def __init__(self, droid):
        self.droid = GetObject__droid(**demangle(droid, ['__typename']))


_GetObjectInput__required = typing.TypedDict("_GetObjectInput__required", {"id": str})
_GetObjectInput__not_required = typing.TypedDict("_GetObjectInput__not_required", {}, total=False)


class _GetObjectInput(_GetObjectInput__required, _GetObjectInput__not_required):
    pass


def _GetObjectInput__serialize(data):
    ret = copy.copy(data)
    return ret


class GetObject(utils.Client[_GetObjectInput, GetObjectResponse]):
    _query = inspect.cleandoc('''
        query GetObject($id: ID!) {
          droid(id: $id) {
            __typename
            id name appearsIn primaryFunction
          }
        }
    ''')
    Input: typing.TypeAlias = _GetObjectInput
    Response: typing.TypeAlias = GetObjectResponse

    @classmethod
    def serialize(cls, data: _GetObjectInput):
        return {
            "operation_name": "GetObject",
            "query": cls._query,
            "variables": _GetObjectInput__serialize(data),
        }

    @classmethod
    def deserialize(cls, data):
        return cls.Response(**data)


################################################################################
# GetInterface
@dataclass
class GetInterfaceResponse:
    hero: GetInterface__hero
    def __init__(self, hero):
        self.hero = GetInterface__hero(**hero)


_GetInterfaceInput__required = typing.TypedDict("_GetInterfaceInput__required", {"e": Episode})
_GetInterfaceInput__not_required = typing.TypedDict("_GetInterfaceInput__not_required", {}, total=False)


class _GetInterfaceInput(_GetInterfaceInput__required, _GetInterfaceInput__not_required):
    pass


def _GetInterfaceInput__serialize(data):
    ret = copy.copy(data)
    return ret


class GetInterface(utils.Client[_GetInterfaceInput, GetInterfaceResponse]):
    _query = inspect.cleandoc('''
        query GetInterface($e: Episode!) {
          hero(episode: $e) {
            id name
          }
        }
    ''')
    Input: typing.TypeAlias = _GetInterfaceInput
    Response: typing.TypeAlias = GetInterfaceResponse

    @classmethod
    def serialize(cls, data: _GetInterfaceInput):
        return {
            "operation_name": "GetInterface",
            "query": cls._query,
            "variables": _GetInterfaceInput__serialize(data),
        }

    @classmethod
    def deserialize(cls, data):
        return cls.Response(**data)


################################################################################
# GetInlineFragment
@dataclass
class GetInlineFragmentResponse:
    hero: GetInlineFragment__hero
    def __init__(self, hero):
        __hero_map = {
            "Human": GetInlineFragment__hero__Human,
            "Droid": GetInlineFragment__hero__Droid,
        }
        self.hero = __hero_map.get(hero["__typename"], GetInlineFragment__hero)(**demangle(hero, ['__typename']))


_GetInlineFragmentInput__required = typing.TypedDict("_GetInlineFragmentInput__required", {"e": Episode})
_GetInlineFragmentInput__not_required = typing.TypedDict("_GetInlineFragmentInput__not_required", {}, total=False)


class _GetInlineFragmentInput(_GetInlineFragmentInput__required, _GetInlineFragmentInput__not_required):
    pass


def _GetInlineFragmentInput__serialize(data):
    ret = copy.copy(data)
    return ret


class GetInlineFragment(utils.Client[_GetInlineFragmentInput, GetInlineFragmentResponse]):
    _query = inspect.cleandoc('''
        query GetInlineFragment($e: Episode!) {
          hero(episode: $e) {
            __typename id name
            ... on Human { totalCredits }
            ... on Droid { primaryFunction }
          }
        }
    ''')
    Input: typing.TypeAlias = _GetInlineFragmentInput
    Response: typing.TypeAlias = GetInlineFragmentResponse

    @classmethod
    def serialize(cls, data: _GetInlineFragmentInput):
        return {
            "operation_name": "GetInlineFragment",
            "query": cls._query,
            "variables": _GetInlineFragmentInput__serialize(data),
        }

    @classmethod
    def deserialize(cls, data):
        return cls.Response(**data)


################################################################################
# GetCustomScalar
@dataclass
class GetCustomScalarResponse:
    today: datetime.date
    def __init__(self, today):
        self.today = datetime.date.fromisoformat(today)


_GetCustomScalarInput__required = typing.TypedDict("_GetCustomScalarInput__required", {})
_GetCustomScalarInput__not_required = typing.TypedDict("_GetCustomScalarInput__not_required", {}, total=False)


class _GetCustomScalarInput(_GetCustomScalarInput__required, _GetCustomScalarInput__not_required):
    pass


def _GetCustomScalarInput__serialize(data):
    ret = copy.copy(data)
    return ret


class GetCustomScalar(utils.Client[_GetCustomScalarInput, GetCustomScalarResponse]):
    _query = inspect.cleandoc('''
        query GetCustomScalar {
          today
        }
    ''')
    Input: typing.TypeAlias = _GetCustomScalarInput
    Response: typing.TypeAlias = GetCustomScalarResponse

    @classmethod
    def serialize(cls, data: _GetCustomScalarInput):
        return {
            "operation_name": "GetCustomScalar",
            "query": cls._query,
            "variables": _GetCustomScalarInput__serialize(data),
        }

    @classmethod
    def deserialize(cls, data):
        return cls.Response(**data)


################################################################################
# GetUnion
@dataclass
class GetUnionResponse:
    search: typing.List[GetUnion__search]
    def __init__(self, search):
        __search_map = {
            "Human": GetUnion__search__Human,
            "Droid": GetUnion__search__Droid,
            "Starship": GetUnion__search__Starship,
        }
        self.search = [__search_map.get(search__iter["__typename"], GetUnion__search)(**demangle(search__iter, ['__typename'])) for search__iter in search]


_GetUnionInput__required = typing.TypedDict("_GetUnionInput__required", {"text": str})
_GetUnionInput__not_required = typing.TypedDict("_GetUnionInput__not_required", {}, total=False)


class _GetUnionInput(_GetUnionInput__required, _GetUnionInput__not_required):
    pass


def _GetUnionInput__serialize(data):
    ret = copy.copy(data)
    return ret


class GetUnion(utils.Client[_GetUnionInput, GetUnionResponse]):
    _query = inspect.cleandoc('''
        query GetUnion($text: String!) {
          search(text: $text) {
            __typename
            ... on Human { totalCredits }
            ... on Droid { friends { name } }
            ... on Starship { name }
          }
        }
    ''')
    Input: typing.TypeAlias = _GetUnionInput
    Response: typing.TypeAlias = GetUnionResponse

    @classmethod
    def serialize(cls, data: _GetUnionInput):
        return {
            "operation_name": "GetUnion",
            "query": cls._query,
            "variables": _GetUnionInput__serialize(data),
        }

    @classmethod
    def deserialize(cls, data):
        return cls.Response(**data)


################################################################################
# GetRecursive
@dataclass
class GetRecursiveResponse:
    hero: GetRecursive__hero
    def __init__(self, hero):
        __hero_map = {
            "Human": GetRecursive__hero__Human,
            "Droid": GetRecursive__hero__Droid,
        }
        self.hero = __hero_map.get(hero["__typename"], GetRecursive__hero)(**demangle(hero, ['__typename']))


_GetRecursiveInput__required = typing.TypedDict("_GetRecursiveInput__required", {"episode": Episode})
_GetRecursiveInput__not_required = typing.TypedDict("_GetRecursiveInput__not_required", {}, total=False)


class _GetRecursiveInput(_GetRecursiveInput__required, _GetRecursiveInput__not_required):
    pass


def _GetRecursiveInput__serialize(data):
    ret = copy.copy(data)
    return ret


class GetRecursive(utils.Client[_GetRecursiveInput, GetRecursiveResponse]):
    _query = inspect.cleandoc('''
        query GetRecursive($episode: Episode!) {
          hero(episode: $episode) {
            __typename
            name
            ... on Human {
              friends {
                __typename
                ... on Human { name }
                ... on Droid { id name }
              }
            }
            ... on Droid {
              primaryFunction
              friends {
                __typename
                id
                ... on Human {
                  name
                  starships { name }
                }
                ... on Droid {
                  name
                  friends { name }
                }
              }
            }
          }
        }
    ''')
    Input: typing.TypeAlias = _GetRecursiveInput
    Response: typing.TypeAlias = GetRecursiveResponse

    @classmethod
    def serialize(cls, data: _GetRecursiveInput):
        return {
            "operation_name": "GetRecursive",
            "query": cls._query,
            "variables": _GetRecursiveInput__serialize(data),
        }

    @classmethod
    def deserialize(cls, data):
        return cls.Response(**data)


################################################################################
# AddStarship
@dataclass
class AddStarshipResponse:
    addStarship: AddStarship__addStarship
    def __init__(self, addStarship):
        self.addStarship = AddStarship__addStarship(**addStarship)


_AddStarshipInput__required = typing.TypedDict("_AddStarshipInput__required", {"input": AddStarshipInput})
_AddStarshipInput__not_required = typing.TypedDict("_AddStarshipInput__not_required", {}, total=False)


class _AddStarshipInput(_AddStarshipInput__required, _AddStarshipInput__not_required):
    pass


def _AddStarshipInput__serialize(data):
    ret = copy.copy(data)
    x = data["input"]
    ret["input"] = AddStarshipInput__serialize(x)
    return ret


class AddStarship(utils.Client[_AddStarshipInput, AddStarshipResponse]):
    _query = inspect.cleandoc('''
        mutation AddStarship($input: AddStarshipInput!) {
          addStarship(input: $input) {
            id name
          }
        }
    ''')
    Input: typing.TypeAlias = _AddStarshipInput
    Response: typing.TypeAlias = AddStarshipResponse

    @classmethod
    def serialize(cls, data: _AddStarshipInput):
        return {
            "operation_name": "AddStarship",
            "query": cls._query,
            "variables": _AddStarshipInput__serialize(data),
        }

    @classmethod
    def deserialize(cls, data):
        return cls.Response(**data)


################################################################################
# AllHuman
@dataclass
class AllHumanResponse:
    allHuman: AllHuman__allHuman
    def __init__(self, allHuman):
        self.allHuman = AllHuman__allHuman(**allHuman)


_AllHumanInput__required = typing.TypedDict("_AllHumanInput__required", {})
_AllHumanInput__not_required = typing.TypedDict("_AllHumanInput__not_required", {}, total=False)


class _AllHumanInput(_AllHumanInput__required, _AllHumanInput__not_required):
    pass


def _AllHumanInput__serialize(data):
    ret = copy.copy(data)
    return ret


class AllHuman(utils.Client[_AllHumanInput, AllHumanResponse]):
    _query = inspect.cleandoc('''
        subscription AllHuman {
          allHuman {
            id name
          }
        }
    ''')
    Input: typing.TypeAlias = _AllHumanInput
    Response: typing.TypeAlias = AllHumanResponse

    @classmethod
    def serialize(cls, data: _AllHumanInput):
        return {
            "operation_name": "AllHuman",
            "query": cls._query,
            "variables": _AllHumanInput__serialize(data),
        }

    @classmethod
    def deserialize(cls, data):
        return cls.Response(**data)
